# -*- coding: utf-8 -*-
"""titanicPreprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gnIiSVXgFQjlTSTZjfKc6GZ9BLLn1jy6
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

titanic=pd.read_csv('/content/TitanicDataSet.csv')
titanic.head()

from google.colab import drive
drive.mount('/content/drive')

#drop columns
titanic.drop('Cabin',
  axis='columns', inplace=True)
titanic.drop('PassengerId',
  axis='columns', inplace=True)
titanic.drop('Ticket',
  axis='columns', inplace=True)
titanic.head()

titanic.dropna(axis=0,how='any',thresh=None,inplace=False)

def editName(x):
  ch=x[x.index(',')+2:x.index('.')]
  return ch
titanic['Name']=titanic['Name'].apply(editName)
titanic.head()

titanic['Name'].unique()

me=titanic['Age'].mean()
sd=titanic['Age'].std()
randAges=np.random.randint(me-sd,me+sd,titanic['Age'].isnull().sum())
titanic['Age'][np.isnan(titanic['Age'])]=randAges
titanic.head(10)

print(titanic['Sex'].isnull().sum(),titanic['Embarked'].isnull().sum(),)
d={'Q':0,'S':1,'C':2}
g={'male':0,'female':1}
titanic['Embarked']=titanic['Embarked'].map(d)
titanic['Sex']=titanic['Sex'].map(g)
titanic.head(10)

plt.title("histogram")
plt.xlabel("Age")
titanic['Age'].plot.hist(by=titanic['Sex'])

titanic['Name'].value_counts()

titanic=titanic[(titanic.Name == 'Mr') | (titanic.Name == 'Miss') | (titanic.Name == 'Mrs') |( titanic.Name == 'Master') ]

d={'Mr':0,'Miss':1,'Mrs':2,'Master':3}
titanic['Name']=titanic['Name'].map(d)
titanic.head(10)

g=sns.FacetGrid(titanic,col='Survived')
g.map(plt.hist,'Age',bins=10)

#titanic.plot.bar(x='Survived',y='Sex')
vc=titanic['Sex'].value_counts()
vc.plot.bar()

def plot_correlation_map( df ):

    corr = df.corr()

    s , ax = plt.subplots( figsize =( 12 , 10 ) )

    cmap = sns.diverging_palette( 220 , 10 , as_cmap = True )

    s = sns.heatmap(

        corr, 

        cmap = cmap,

        square=True, 

        cbar_kws={ 'shrink' : .9 }, 

        ax=ax, 

        annot = True, 

        annot_kws = { 'fontsize' : 12 }

        )

plot_correlation_map(titanic)

#import relevant libraries
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
import math
#features extraction
x = titanic[['Pclass', 'Name','Sex','SibSp','Parch','Fare']]
y = titanic['Survived']

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=0)  #splitting data with test size of 25%
"""print(x_train.describe())
print(x_train.shape, y_train.shape)
rows_with_nan = [index for index, row in x_train.iterrows() if row.isnull().any()]
print(rows_with_nan)"""
logreg = LogisticRegression()   #build our logistic model
"""print(type(x_train))
ds = x_train.isin([np.inf, -np.inf])
x_train = x_train[np.all(np.isfinite(x_train), axis=1)]
print(np.isinf(y_train).values.sum(),y_train.isnull().sum().sum()
)

print(x_train.shape, y_train.shape)"""
logreg.fit(x_train, y_train)  #fitting training data
y_pred  = logreg.predict(x_test)    #testing modelâ€™s performance
print("Accuracy={:.2f}".format(logreg.score(x_test, y_test)))

confusion_matrix = pd.crosstab(y_test, y_pred, rownames=['Survived'], colnames=['Predicted'])
sns.heatmap(confusion_matrix, annot=True)

"""from sklearn.neighbors import KNeighborsClassifier

model2 = KNeighborsClassifier(n_neighbors=4)
model2.fit(x_train, y_train)
pred_prob2 = model2.predict_proba(x_test)"""
pred_prob1 = logreg.predict_proba(x_test)
from sklearn.metrics import roc_curve

# roc curve for models
fpr1, tpr1, thresh1 = roc_curve(y_test, pred_prob1[:,1], pos_label=1)
# roc curve for tpr = fpr 
random_probs = [0 for i in range(len(y_test))]
p_fpr, p_tpr, _ = roc_curve(y_test, random_probs, pos_label=1)
from sklearn.metrics import roc_auc_score

# auc scores
auc_score1 = roc_auc_score(y_test, pred_prob1[:,1])
print(auc_score1)

plt.style.use('seaborn')

# plot roc curves
plt.plot(fpr1, tpr1, linestyle='--',color='orange', label='Logistic Regression')
plt.plot(p_fpr, p_tpr, linestyle='--', color='blue')
plt.title('ROC curve')
# x label
plt.xlabel('False Positive Rate')
# y label
plt.ylabel('True Positive rate')

plt.legend(loc='best')
plt.savefig('ROC',dpi=300)
plt.show();

#
#
#I found an other Multiclass ROC curve so i will add it if it's required
#
#